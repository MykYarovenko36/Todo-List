React.createElement('h1', null, 'hello world') || 
const el = <h1>Hello world</h1>;
ReactDOM.render(el, document.getElementById('root')); 
> объекты создаются при помощи JSX 
>Virtual DOM
>ReactDOM.render() React DOM;
-----------------------------------------------------
React компоненты
const Header = () => return (
    <h1>Hi</h1>
);
> Функции, которые возвращают React-element;
> Должны начинаться с большой буквы;
> Имя затем можно использовать в JSX как будто это HTML тег;
-----------------------------------------------------
JSX
> Позволяет использовать выражения {foo.bar}
> Атрибуты называются camelCase`oм
> class = className, for = HMTLFor
> В свойства можно передать любое значение
> null, undefined, true, false в теле тегов игнорируются (не вызывая ошибок)
------------------------------------------------------
> Один компонент - один файл
> Помещаем все компоненты в папку components
> Хорошие компоненты независимые компоненты
------------------------------------------------------
> Объект props передается в каждый компонент
 const Comp = (props => {
return (<i>{ props.name }</i>);
}
> Можно передавать любые значения (не только строки)
------------------------------------------------------
> Массив можно передать как свойство
> В JSX можно вставлять массивы элементов (не только по одному)
> Можно передать все свойства объекта в компонент используя Object Spread 
оператор (не перечисляя каждое)
------------------------------------------------------
> Каждому JSX элементу в массиве нужно уникальное свойство key;
> React использует key чтобы эффективно сравнивать элементы при обновлении
> Не стоит делать ключи из индексов массива
> React проставит ключи самостоятельно в порядке индексов массива, если они не будут указаны, и при отрисовке
будет сравнивать свои собственные ключи. (такого лучше избегать).

-------------------------- Bootstrap и структура React проекта --------------------------------
  Bootstrap - open sourse library; Bootstrapcdn.com
  <link ref="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"> - css styles
  <link ref="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"> - css fonts
> Файлы компонента удобно хранить в отдельной папке
> Кроме JS и CSS у компонента могут быть файлы с юнит-тестами
и другими ресурсами
> Если в папке есть файл index.js, то он импортируется по умолчанию

---------------------------- Компоненты-классы -------------------------------------------------
> Классы используются, когда нужно хранить состояние
> Классы наследуют React.Component
> Метод render() возвращаетт элемент (как в функциональном компоненте)
> props доступны через this.props

------------------------------ Обработка событий -----------------------------------------------
> Добавить свойство onClick (onBlur, onMouseOver, and etc) к элементу
> Передать функцию
> Убедиться, что this сохранит правильное значение внутри функции (типичная ошибка) 

---------------------------------State - состояние компонента ----------------------------------
> Состояние хранится в поле state
> tihs.state инициализируется в конструкторе или в теле класса
> После инициализации state нельзя изменять (только читать)
> Чтобы обновить state - setState()

--------------------------------как работает setState() ----------------------------------------
> В setState() нужно передавать только изменения в state

--------------------------------Обновление состояния, которое зависит от предидущего------------
> setState принимает функцию 
> аргумент - текущий state 
//  this.setState((state) => {
      return {
	    count: state.count + 1
	  }
    });
------------------------------- Собственная система событий -------------------------------------
> Любой компонент может генерировать собственные события (onDone, onAdded....)
> Достаточно передать callback функцию, как property, а затем вызвать ее из компонента, когда наступило событие.
> Через события, данные поднимаются "вверх" по иерархии компонентов

-------------------------------------setState() - удалить элемент-------------------------------------
> setState() не должен изменять текущий state
> методы которые изменяют(mutate) массив использовать нельзя
> const newArray = [ 
          ...todoData.slice(0, index), 
          ...todoData.slice(index + 1)
        ];
  // не изменяет oldArr
------------------------------------ добавление элементов ---------------------------------------------
> arr.push() - тоже изменение массива (нельзя выполнять на массивах из state)
// добавить элемент в конец массива 
const newArray = [ ...oldArr, newItem];
// добавить элеммент в начало массива 
const newArr = [newItem, ...oldArr];

----------------------------------------Данные в React приложении--------------------------------------
> Централизировать управление данными - хорошая практика
> Если данные нужно использовать в нескольких компонентах - их нужно хранить в родительском компоненте 
> Чтобы "поднять" данные вверх по иерархии компонентов, используйте события.

----------------------------------------setState()-изменить элемент------------------------------------
> oldObj нельзя изменять
  oldObj = oldArr[idx]
> но можно скопировать в новый объект
  newObj = { ...oldObj, porp: newValue};
> newArr = [ ...oldArr.slice(0, idx), newObj, ...oldArr.slice(idx + 1)];

------------------------------------------Работа с формами---------------------------------------------
> Используем onChange() чтобы получать текущее значение
> onSubmit() - событие "отправки формы"
> e.preventDefault() - чтобы страница не перезагружалась

-------------------------------------------Контрольруемые компоненты------------------------------------
> onChange() обновляет state, а state обновляет value элемента
> state - единственный источник значений
> легко обновлять value, можно обновлять не только в ответ на вод пользователя
-------------------------------------------Реализуем поиск ---------------------------------------------
> Компонент App получил новый элемент state, котором мы храним текст для поиска
> Перед тем, как отображать элементы в render() мы отфильтровываем нужные.
> Компонент SearchPanel генерирует событие onSearchChange на каждое нажатие клавиши (чтобы App обновлял список)
> Фильтры работают на 90% так же, как поиск 
> В компоненте ItemStatusFilter мы вынесли описание кнопок в отдельный массив, чтобы не дублировать if`ы для каждой
> Текущая активная кнопка передается, как свойство. Это продолжение идеи "контролируемых компонентов"
--------------------------------------------------------------------------------------------------------













